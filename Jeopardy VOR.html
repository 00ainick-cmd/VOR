<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1"><title>Jeopardy â€” Player vs AI</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #111827;
    --panel: #1f2937;
    --board: #111827;
    --tile: #4f46e5;
    --tile-hover: #6366f1;
    --tile-text: #f59e0b;
    --ink: #e5e7eb;
    --ink-dim: #9ca3af;
    --border: #374151;
    --ok: #22c55e;
    --warn: #f59e0b;
    --err: #ef4444;
    --player: #3b82f6;
    --ai: #f43f5e;
    --font-heading: 'Montserrat', sans-serif;
    --font-body: 'Roboto', sans-serif;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: var(--font-body);
    background: var(--bg);
    color: var(--ink);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  .wrap{max-width:1200px;margin:0 auto;padding:16px;display:grid;gap:16px}
  .top{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between}
  .badge{padding:6px 12px;border-radius:999px;background:var(--panel);border:1px solid var(--border);color:var(--ink-dim); font-size: 0.9rem; font-weight: 700;}

  /* Scores Section */
  .scores{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px}
  .player-box{
    background:var(--panel);
    border:2px solid var(--player);
    border-radius:12px;
    padding:16px;
    text-align:center;
  }
  .player-box.active{
    box-shadow: 0 0 20px var(--player);
    animation: pulse 1.5s ease-in-out infinite;
  }
  .ai-box{
    background:var(--panel);
    border:2px solid var(--ai);
    border-radius:12px;
    padding:16px;
    text-align:center;
  }
  .ai-box.active{
    box-shadow: 0 0 20px var(--ai);
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .player-name{font-size:0.9rem;color:var(--ink-dim);margin-bottom:4px}
  .player-score{font-size:2rem;font-weight:900;color:var(--player);font-family:var(--font-heading)}
  .ai-score{font-size:2rem;font-weight:900;color:var(--ai);font-family:var(--font-heading)}
  .turn-indicator{margin-top:8px;font-size:0.85rem;font-weight:700;color:var(--tile-text)}

  .board{
    background: var(--panel);
    border-radius: 16px;
    border: 1px solid var(--border);
    padding: 16px;
    display: grid;
    gap: 12px;
    box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3), 0 8px 10px -6px rgba(0,0,0,0.3);
  }
  .row{display:grid;gap:12px}
  .row-3{grid-template-columns:repeat(3,1fr)}
  .tile{
    display: grid;
    place-items: center;
    padding: 18px;
    border-radius: 12px;
    background: var(--tile);
    border: none;
    color: var(--tile-text);
    font-family: var(--font-heading);
    font-weight: 900;
    font-size: 1.6rem;
    cursor: pointer;
    min-height: 80px;
    text-align: center;
    user-select: none;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    transition: transform 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    position: relative;
  }
  .tile:not(.used):hover{
    transform: scale(1.05);
    background: var(--tile-hover);
    box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
  }
  .tile.used{
    background: rgba(31, 41, 55, 0.5);
    color: #6b7280;
    cursor: not-allowed;
    text-shadow: none;
  }
  .tile.ai-thinking{
    animation: ai-glow 0.5s ease-in-out infinite alternate;
  }
  @keyframes ai-glow{
    from{box-shadow: 0 0 10px var(--ai)}
    to{box-shadow: 0 0 25px var(--ai)}
  }
  .cats{gap:12px;margin-bottom:8px}
  .cat{
    display: grid;
    place-items: center;
    padding: 10px;
    border-radius: 10px;
    background: var(--bg);
    color: var(--ink);
    border: 1px solid var(--border);
    font-family: var(--font-heading);
    font-weight: 700;
    min-height: 50px;
    text-align: center;
    font-size: 0.9rem;
  }

  .round-indicator{
    padding: 8px 16px;
    border-radius: 999px;
    background: var(--tile);
    border: 2px solid var(--tile-hover);
    color: white;
    font-weight: 900;
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 8px rgba(79, 70, 229, 0.4);
  }

  /* Buzzer Section */
  .buzzer-section{
    display:grid;
    gap:12px;
    margin-top:16px;
    grid-template-columns: 1fr 1fr;
  }
  .buzz-btn{
    padding: 20px;
    border-radius: 12px;
    font-size: 1.3rem;
    font-weight: 900;
    font-family: var(--font-heading);
    cursor: pointer;
    border: 3px solid;
    transition: all 0.15s ease;
    text-transform: uppercase;
  }
  .player-buzz{
    background: var(--player);
    border-color: var(--player);
    color: white;
  }
  .player-buzz:hover:not(:disabled){
    transform: scale(1.05);
    box-shadow: 0 0 30px var(--player);
  }
  .player-buzz:disabled{
    opacity: 0.3;
    cursor: not-allowed;
  }
  .player-buzz.winner{
    animation: buzz-winner 0.5s ease;
    box-shadow: 0 0 40px var(--player);
  }
  .ai-buzz{
    background: var(--ai);
    border-color: var(--ai);
    color: white;
    cursor: default;
  }
  .ai-buzz.winner{
    animation: buzz-winner 0.5s ease;
    box-shadow: 0 0 40px var(--ai);
  }
  @keyframes buzz-winner{
    0%,100%{transform:scale(1)}
    50%{transform:scale(1.1)}
  }

  .qhead{display:flex;align-items:center;justify-content:space-between;gap:10px; flex-wrap: wrap;}
  .qtext{font-size:1.2rem;line-height:1.6;color:#ffffff; font-weight: 500; margin: 8px 0;}
  .choices{display:grid;gap:10px;margin-top:16px}
  .choice{
    display:flex;gap:12px;align-items:center;padding:14px;border-radius:10px;border:1px solid var(--border);background:var(--bg);color:var(--ink);cursor:pointer;
    transition: transform 0.15s ease, background-color 0.15s ease;
    text-align: left;
    font-size: 1rem;
    line-height: 1.4;
  }
  .choice:hover:not(:disabled){background:#374151; transform: translateY(-2px);}
  .choice.correct{border-color:var(--ok); background:rgba(34, 197, 94, 0.1); color: var(--ok);}
  .choice.wrong{border-color:var(--err); background:rgba(239, 68, 68, 0.1); color: var(--err);}
  .choice > strong { color: var(--tile-text); }
  .choice.correct > strong, .choice.wrong > strong { color: inherit; }

  .explanation{
    margin-top: 16px;
    padding: 16px;
    background: rgba(59, 130, 246, 0.1);
    border: 1px solid #3b82f6;
    border-radius: 10px;
    line-height: 1.6;
  }
  .explanation h4{
    margin: 0 0 8px 0;
    color: #3b82f6;
    font-size: 1.1rem;
  }
  .explanation p{
    margin: 8px 0;
    color: var(--ink);
  }
  .explanation small{
    color: var(--ink-dim);
    font-style: italic;
  }

  .meta{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .kpi{font-variant-numeric:tabular-nums;font-weight:700; color: var(--tile-text);}
  .btn{
    padding: 10px 16px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: #374151;
    color: var(--ink);
    cursor: pointer;
    font-weight: 700;
    transition: transform 0.15s ease, background-color 0.15s ease;
  }
  .btn:hover{background: #4b5563; transform: translateY(-2px);}
  .btn.ghost{background:transparent;color:var(--ink-dim);border-color:var(--border)}
  .btn.ghost:hover{color: var(--ink); background: var(--panel);}
  .center{text-align:center}
  .hidden{display:none}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  
  .timer {
    display:flex;
    align-items:center;
    gap:8px;
  }
  #qTimer {
    background:var(--bg);
    border:1px solid var(--border);
    padding: 6px 12px;
    border-radius: 999px;
  }
  .bar{height:10px;background:var(--bg);border-radius:999px;overflow:hidden;width:100px;border:1px solid var(--border)}
  .bar>div{
    height:100%;
    background:linear-gradient(90deg, var(--ok), var(--warn), var(--err));
    width:100%;
    transition: width 1s linear;
  }

  .overlay{position:fixed;inset:0;pointer-events:none; z-index: 200;}
  .confetti i{position:absolute;width:8px;height:14px;opacity:.95;animation:fall 1.6s linear forwards}
  @keyframes fall{to{transform:translateY(120vh) rotate(360deg);opacity:.2}}

  .modal{
    position:fixed;
    inset:0;
    background:rgba(17, 24, 39, 0.9);
    backdrop-filter: blur(4px);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:16px;
    z-index:100;
    opacity: 0;
    transform: scale(0.98);
    pointer-events: none;
    visibility: hidden;
    transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s 0.2s;
  }
  .modal.show{
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
    visibility: visible;
    transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s 0s;
  }
  .card{
    background: var(--panel);
    color: var(--ink);
    border: 1px solid var(--border);
    border-radius: 16px;
    max-width: 650px;
    width: 100%;
    padding: 24px;
    display: grid;
    gap: 12px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.4);
    max-height: 90vh;
    overflow-y: auto;
  }
  .card h2{margin:0;font-family: var(--font-heading); font-size:1.6rem; color: var(--tile-text);}
  .input{display:flex;gap:8px;align-items:center}
  .input input{flex:1;padding:10px;border-radius:10px;border:1px solid var(--border);background:var(--bg);color:var(--ink); font-size: 1rem;}

  #gameEndModal .card {
      padding: 0;
      overflow: hidden;
      text-align: center;
      max-width: 500px;
  }
  .endGameContent {
      padding: 24px;
      display: grid;
      gap: 12px;
  }
  .endGameContent h2 {
      font-size: 2.2rem;
      color: var(--tile-text);
      margin-bottom: 5px;
      text-shadow: 2px 2px 5px rgba(0,0,0,0.4);
  }
  .endGameContent .final-scores{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 16px 0;
  }
  .endGameContent .score-box{
      padding: 12px;
      border-radius: 10px;
      border: 2px solid;
  }
  .endGameContent .player-final{
      border-color: var(--player);
      background: rgba(59, 130, 246, 0.1);
  }
  .endGameContent .ai-final{
      border-color: var(--ai);
      background: rgba(244, 63, 94, 0.1);
  }
  .endGameContent p {
      color: var(--ink-dim);
      line-height: 1.5;
  }
  #finalRestartBtn {
      background: var(--tile);
      color: #fff;
      font-size: 1.1rem;
      padding: 12px 24px;
      border: none;
      box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3);
  }
  #finalRestartBtn:hover {
      background: var(--tile-hover);
      box-shadow: 0 6px 15px rgba(79, 70, 229, 0.5);
  }

  .round-transition{
    position:fixed;
    inset:0;
    background:rgba(17, 24, 39, 0.95);
    backdrop-filter: blur(8px);
    display:flex;
    flex-direction: column;
    align-items:center;
    justify-content:center;
    z-index:150;
    opacity: 0;
    pointer-events: none;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s 0.3s;
  }
  .round-transition.show{
    opacity: 1;
    pointer-events: auto;
    visibility: visible;
    transition: opacity 0.3s ease, visibility 0s 0s;
  }
  .round-transition h1{
    font-family: var(--font-heading);
    font-size: 3.5rem;
    color: var(--tile-text);
    margin: 0;
    text-shadow: 0 0 30px rgba(245, 158, 11, 0.5);
    animation: glow 2s ease-in-out infinite;
  }
  @keyframes glow{
    0%,100%{text-shadow: 0 0 30px rgba(245, 158, 11, 0.5)}
    50%{text-shadow: 0 0 50px rgba(245, 158, 11, 0.8)}
  }
  .round-transition p{
    font-size: 1.3rem;
    color: var(--ink);
    margin-top: 16px;
  }

  @media (max-width:780px){ 
    .row-3{grid-template-columns:1fr} 
    .tile{min-height:56px} 
    .qtext{font-size:1.05rem}
    .scores{grid-template-columns:1fr}
    .buzzer-section{grid-template-columns:1fr}
    .round-transition h1{font-size: 2.5rem}
  }
</style>
</head>
<body>

<div class="wrap">
  <div class="top">
    <div class="badge">Electrical Systems Jeopardy â€” Player vs AI</div>
    <div class="meta">
      <span class="round-indicator" id="roundIndicator">ROUND 1: JEOPARDY</span>
      <span>Tiles left: <span class="kpi" id="qLeft">15</span></span>
      <button id="mute" class="btn ghost">ðŸ”ˆ Sound</button>
      <button id="difficultyBtn" class="btn ghost">AI: Medium</button>
    </div>
  </div>

  <div class="scores">
    <div class="player-box" id="playerBox">
      <div class="player-name">YOU</div>
      <div class="player-score" id="pScore">$0</div>
      <div class="turn-indicator" id="playerTurn"></div>
    </div>
    <div class="ai-box" id="aiBox">
      <div class="player-name">AI OPPONENT</div>
      <div class="ai-score" id="aiScore">$0</div>
      <div class="turn-indicator" id="aiTurn"></div>
    </div>
  </div>

  <div class="board">
    <div class="cats row row-3" id="catRow"></div>
    <div class="row row-3" id="valRow1"></div>
    <div class="row row-3" id="valRow2"></div>
    <div class="row row-3" id="valRow3"></div>
    <div class="row row-3" id="valRow4"></div>
    <div class="row row-3" id="valRow5"></div>
  </div>
</div>

<div class="round-transition" id="roundTransition">
  <h1 id="transitionTitle">DOUBLE JEOPARDY</h1>
  <p id="transitionSubtitle">All values are doubled!</p>
</div>

<div class="modal" id="qCard">
  <div class="card">
    <div class="qhead">
      <div class="meta"><span id="qCat" class="badge"></span><span id="qValue" class="badge"></span></div>
      <div class="meta">
        <div class="timer" id="qTimer">
          <span>Time:</span>
          <div class="bar"><div id="tFill"></div></div>
          <span class="kpi" id="tLeft">10</span>s
        </div>
        <span class="badge" id="ddBadge" style="display:none;background:var(--warn);border-color:var(--warn);color:#111;">DAILY DOUBLE</span>
      </div>
    </div>
    <div class="qtext" id="qText">Question</div>
    
    <div id="buzzSection" class="buzzer-section hidden">
      <button class="buzz-btn player-buzz" id="playerBuzz" disabled>ðŸ”µ BUZZ IN!</button>
      <button class="buzz-btn ai-buzz" id="aiBuzz">ðŸ”´ AI</button>
    </div>

    <div class="choices" id="choices"></div>
    <div id="feedback" class="center"></div>
    <div class="center" style="margin-top:10px;">
      <button id="closeQ" class="btn hidden">Continue</button>
    </div>
  </div>
</div>

<div class="modal" id="finalCard">
  <div class="card">
    <div class="qhead">
      <div class="meta"><span class="badge" id="finalCat">Final Category</span></div>
      <div class="meta"><span class="badge" style="background:#a855f7;border-color:#a855f7;color:#fff;">FINAL JEOPARDY</span></div>
    </div>
    <div class="qtext" id="finalText">Final question textâ€¦</div>
    <div class="choices" id="finalChoices"></div>
    <div id="finalFeedback" class="center"></div>
    <div class="center" style="margin-top:10px;">
      <button id="closeFinal" class="btn hidden">See Results</button>
    </div>
  </div>
</div>

<div class="overlay confetti" id="confetti"></div>

<div class="modal" id="ddModal">
  <div class="card">
    <h2 id="ddTitle">DAILY DOUBLE!</h2>
    <div id="ddWho"></div>
    <div id="ddScoreDisplay"></div>
    <div id="ddWagerSection"></div>
    <div class="meta" id="ddButtons"></div>
  </div>
</div>

<div class="modal" id="fjModal">
  <div class="card">
    <h2>FINAL JEOPARDY</h2>
    <div>Category: <b id="fjCat">Category</b></div>
    <div style="margin:16px 0">
      <div style="margin-bottom:8px">Your Score: <b class="kpi" style="color:var(--player)" id="fjPScore">$0</b></div>
      <div class="input"><span>Your Wager: $</span><input id="fjPWager" type="number" min="0" step="50" value="0"></div>
    </div>
    <div style="margin:16px 0">
      <div style="margin-bottom:8px">AI Score: <b class="kpi" style="color:var(--ai)" id="fjAIScore">$0</b></div>
      <div>AI Wager: <b class="kpi" style="color:var(--ai)" id="fjAIWager">$???</b> (Hidden)</div>
    </div>
    <div class="meta">
      <button id="fjStart" class="btn">Reveal Final Question</button>
    </div>
  </div>
</div>

<div class="modal" id="gameEndModal">
  <div class="card">
    <div class="endGameContent">
      <h2 id="endGameTitle">Game Over!</h2>
      <div class="final-scores">
        <div class="score-box player-final">
          <div style="font-size:0.9rem;color:var(--ink-dim)">YOU</div>
          <div class="kpi" style="color:var(--player);font-size:1.8rem" id="endPlayerScore">$0</div>
        </div>
        <div class="score-box ai-final">
          <div style="font-size:0.9rem;color:var(--ink-dim)">AI</div>
          <div class="kpi" style="color:var(--ai);font-size:1.8rem" id="endAIScore">$0</div>
        </div>
      </div>
      <p id="endGameMessage">Thanks for playing!</p>
      <button id="finalRestartBtn" class="btn">Play Again</button>
    </div>
  </div>
</div>

<script>
/* ========================================================================
   QUESTION BANK - CUSTOMIZE THIS SECTION FOR DIFFERENT JEOPARDY GAMES
   ========================================================================

   TO CREATE A NEW JEOPARDY GAME:
   1. Keep the structure exactly the same
   2. Change category names (must have exactly 6 categories + FINAL)
   3. Update questions, answers, and explanations for your topic
   4. Each category needs exactly 5 questions
   5. Round 1 categories use base values: $100, $200, $300, $400, $500
   6. Round 2 categories use doubled values: $200, $400, $600, $800, $1000

   STRUCTURE:
   - First 3 categories = Round 1 (Jeopardy)
   - Next 3 categories = Round 2 (Double Jeopardy) 
   - FINAL = Final Jeopardy question

   ======================================================================== */

const QUESTION_BANK = {
  // ==================== ROUND 1: JEOPARDY ====================

  "VOR Basics": [
    {
      id: "vor-001",
      difficulty: 1,
      pointValue: 100,
      timeLimit: 10,
      question: "VOR stands for this type of VHF navigation system.",
      answers: ["VHF Omni Radar", "VHF Omnidirectional Range", "Very high Optical Receiver", "Visual Orientation Radial"],
      correctIndex: 1,
      explanation: "VOR stands for VHF Omnidirectional Range, providing azimuth (bearing) information to aircraft.",
      reference: "VOR Fundamentals"
    },
    {
      id: "vor-002",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "VOR stations operate in this VHF frequency range.",
      answers: ["118.0 to 135.95 MHz", "108.0 to 117.95 MHz", "960 to 1215 MHz", "225 to 400 MHz"],
      correctIndex: 1,
      explanation: "VOR stations transmit in the VHF band from 108.0 to 117.95 MHz, spaced 50 kHz apart.",
      reference: "VOR Frequencies"
    },
    {
      id: "vor-003",
      difficulty: 3,
      pointValue: 300,
      timeLimit: 14,
      question: "A VOR radial is defined as a magnetic bearing in this direction from the station.",
      answers: ["TO the station", "FROM the station", "Around the station", "Above the station"],
      correctIndex: 1,
      explanation: "A VOR radial is a magnetic bearing FROM the VOR station, extending outward like spokes on a wheel.",
      reference: "VOR Radials"
    },
    {
      id: "vor-004",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 15,
      question: "VOR determines bearing by comparing two signals at this frequency.",
      answers: ["9960 Hz", "1020 Hz", "30 Hz", "400 Hz"],
      correctIndex: 2,
      explanation: "VOR compares two 30 Hz signals: a reference phase and a variable phase that rotates at 1800 RPM.",
      reference: "VOR Phase Comparison"
    },
    {
      id: "vor-005",
      difficulty: 4,
      pointValue: 500,
      timeLimit: 18,
      question: "In the 108.0-111.95 MHz range, VOR frequencies typically use this decimal pattern.",
      answers: ["Even tenths (.0, .2, .4, .6, .8)", "Odd tenths (.1, .3, .5, .7, .9)", "All frequencies", "Only whole numbers"],
      correctIndex: 1,
      explanation: "VORs use odd tenth frequencies (.1, .3, .5, .7, .9) while ILS localizers use even tenths in the shared range.",
      reference: "VOR/ILS Frequency Pairing"
    }
  ],

  "VOR Instruments": [
    {
      id: "inst-001",
      difficulty: 1,
      pointValue: 100,
      timeLimit: 10,
      question: "CDI stands for this primary VOR navigation instrument.",
      answers: ["Compass Direction Indicator", "Course Deviation Indicator", "Central Display Interface", "Corrected Distance Indicator"],
      correctIndex: 1,
      explanation: "CDI (Course Deviation Indicator) displays lateral deviation from a selected course using a vertical needle.",
      reference: "VOR Instruments"
    },
    {
      id: "inst-002",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "Each dot on the CDI represents approximately this many degrees of deviation.",
      answers: ["1 degree", "2 degrees", "5 degrees", "10 degrees"],
      correctIndex: 1,
      explanation: "Each CDI dot represents approximately 2Â° of deviation, or about 200 feet per nautical mile from course.",
      reference: "CDI Sensitivity"
    },
    {
      id: "inst-003",
      difficulty: 3,
      pointValue: 300,
      timeLimit: 14,
      question: "OBS stands for this VOR control that selects desired radials.",
      answers: ["Omni Bearing Selector", "Outbound Bearing System", "Orbital Bearing Sensor", "Offset Bearing Scale"],
      correctIndex: 0,
      explanation: "OBS (Omni Bearing Selector) is the rotating knob that allows selection of any of the 360 radials.",
      reference: "VOR Controls"
    },
    {
      id: "inst-004",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 15,
      question: "A blank or OFF flag on the VOR indicator means this about the signal.",
      answers: ["Signal is too strong", "Signal is unreliable or absent", "Station is in test mode only", "Aircraft is too high"],
      correctIndex: 1,
      explanation: "An OFF flag indicates unreliable or no signal due to weak reception, station outage, or receiver malfunction.",
      reference: "VOR Flag Warnings"
    },
    {
      id: "inst-005",
      difficulty: 4,
      pointValue: 500,
      timeLimit: 18,
      question: "The TO/FROM indicator shows this when you are on a radial flying away from the station.",
      answers: ["TO", "FROM", "OFF", "It alternates"],
      correctIndex: 1,
      explanation: "When flying away from the station on a radial, the TO/FROM indicator shows FROM.",
      reference: "TO/FROM Indicator"
    }
  ],

  "VOR Navigation": [
    {
      id: "nav-001",
      difficulty: 1,
      pointValue: 100,
      timeLimit: 10,
      question: "Each VOR station identifies itself by transmitting this type of code.",
      answers: ["Binary code", "Voice only", "Three-letter Morse code", "Numeric identifier"],
      correctIndex: 2,
      explanation: "VOR stations transmit a unique three-letter Morse code identifier every 10 seconds or less.",
      reference: "VOR Station Identification"
    },
    {
      id: "nav-002",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "This Morse code identifier means the VOR station is unreliable.",
      answers: ["T-E-S-T", "O-F-F", "N-O-G-O", "F-A-I-L"],
      correctIndex: 0,
      explanation: "A T-E-S-T identifier or absence of identification indicates the VOR is unreliable and should not be used.",
      reference: "VOR Test Mode"
    },
    {
      id: "nav-003",
      difficulty: 3,
      pointValue: 300,
      timeLimit: 14,
      question: "This navigation error occurs when flying outbound with the OBS set to the reciprocal course.",
      answers: ["Cone of confusion", "Reverse sensing", "Scalloping", "Quadrantal error"],
      correctIndex: 1,
      explanation: "Reverse sensing makes the CDI needle deflect opposite to the correction needed. Use FROM indication when flying away.",
      reference: "VOR Reverse Sensing"
    },
    {
      id: "nav-004",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 15,
      question: "The area directly above a VOR station where signals are unreliable is called this.",
      answers: ["Dead zone", "Null area", "Cone of confusion", "Signal void"],
      correctIndex: 2,
      explanation: "The cone of confusion extends from the station to about 3,000 feet AGL where TO/FROM fluctuates and bearing is unusable.",
      reference: "Cone of Confusion"
    },
    {
      id: "nav-005",
      difficulty: 4,
      pointValue: 500,
      timeLimit: 18,
      question: "Course width from a VOR increases at approximately this rate per nautical mile.",
      answers: ["100 feet/NM", "200 feet/NM", "400 feet/NM", "1000 feet/NM"],
      correctIndex: 1,
      explanation: "Course width increases at 200 feet per nautical mile (based on 2Â° per dot CDI sensitivity).",
      reference: "VOR Course Sensitivity"
    }
  ],

  // ==================== ROUND 2: DOUBLE JEOPARDY ====================

  "VOR Testing": [
    {
      id: "test-201",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "VOR ground stations must maintain bearing accuracy within this tolerance.",
      answers: ["Â±0.5Â°", "Â±1Â°", "Â±2Â°", "Â±4Â°"],
      correctIndex: 1,
      explanation: "VOR ground stations must maintain bearing accuracy within Â±1Â° under normal conditions.",
      reference: "VOR Accuracy Standards"
    },
    {
      id: "test-202",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 14,
      question: "VOT stands for this type of VOR test facility.",
      answers: ["VOR Offset Test", "VOR Omni Tracker", "VOR Test Facility", "VOR Operational Tester"],
      correctIndex: 2,
      explanation: "VOT (VOR Test Facility) transmits a 360Â° radial for receiver testing with Â±4Â° tolerance.",
      reference: "VOR Testing"
    },
    {
      id: "test-203",
      difficulty: 4,
      pointValue: 600,
      timeLimit: 16,
      question: "VOR receivers must be tested this often for IFR flight operations.",
      answers: ["Every 15 days", "Every 30 days", "Every 60 days", "Every 100 hours"],
      correctIndex: 1,
      explanation: "FAR 91.171 requires VOR receiver checks every 30 days for IFR operations.",
      reference: "VOR Testing Requirements"
    },
    {
      id: "test-204",
      difficulty: 4,
      pointValue: 800,
      timeLimit: 18,
      question: "The tolerance for a VOR ground checkpoint is this many degrees.",
      answers: ["Â±2Â°", "Â±4Â°", "Â±6Â°", "Â±8Â°"],
      correctIndex: 1,
      explanation: "VOR ground checkpoints must indicate within Â±4Â° of the published radial.",
      reference: "VOR Checkpoint Tolerances"
    },
    {
      id: "test-205",
      difficulty: 5,
      pointValue: 1000,
      timeLimit: 20,
      question: "When performing a VOR dual check, the two receivers must agree within this tolerance.",
      answers: ["Â±2Â°", "Â±4Â°", "Â±6Â°", "Â±10Â°"],
      correctIndex: 1,
      explanation: "For a VOR dual check, two independent receivers must indicate bearings within 4Â° of each other.",
      reference: "VOR Dual Check"
    }
  ],

  "VOR Types & Facilities": [
    {
      id: "fac-201",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "VORTAC combines VOR with this military navigation system.",
      answers: ["RADAR", "TACAN", "GPS", "LORAN"],
      correctIndex: 1,
      explanation: "VORTAC combines VOR (civilian azimuth) with TACAN (military distance/azimuth) at the same location.",
      reference: "VORTAC"
    },
    {
      id: "fac-202",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 14,
      question: "DME in a VOR/DME facility operates in this frequency range.",
      answers: ["108-118 MHz", "225-400 MHz", "960-1215 MHz", "1030-1090 MHz"],
      correctIndex: 2,
      explanation: "DME (Distance Measuring Equipment) operates on UHF frequencies between 960 and 1215 MHz.",
      reference: "VOR/DME"
    },
    {
      id: "fac-203",
      difficulty: 4,
      pointValue: 600,
      timeLimit: 16,
      question: "DVOR stands for this advanced type of VOR system.",
      answers: ["Digital VOR", "Doppler VOR", "Dual VOR", "Directional VOR"],
      correctIndex: 1,
      explanation: "DVOR (Doppler VOR) uses Doppler effect instead of mechanical rotation for the variable phase signal.",
      reference: "Doppler VOR"
    },
    {
      id: "fac-204",
      difficulty: 4,
      pointValue: 800,
      timeLimit: 18,
      question: "A Terminal VOR provides service up to this distance and altitude.",
      answers: ["25 NM / 12,000 ft", "40 NM / 18,000 ft", "100 NM / 45,000 ft", "130 NM / 60,000 ft"],
      correctIndex: 0,
      explanation: "Terminal (T) VORs provide service to 25 NM up to 12,000 feet AGL.",
      reference: "VOR Service Volumes"
    },
    {
      id: "fac-205",
      difficulty: 5,
      pointValue: 1000,
      timeLimit: 20,
      question: "DVOR systems have this advantage over conventional VOR.",
      answers: ["Longer range", "Higher power", "Less site error", "Faster signal processing"],
      correctIndex: 2,
      explanation: "DVORs are less susceptible to site error from terrain reflections and are more accurate than conventional VORs.",
      reference: "DVOR Advantages"
    }
  ],

  "VOR Errors & Troubleshooting": [
    {
      id: "err-201",
      difficulty: 2,
      pointValue: 200,
      timeLimit: 12,
      question: "VOR signals propagate by this method, limiting reception to line-of-sight.",
      answers: ["Ground wave", "Sky wave", "Line-of-sight VHF", "Tropospheric scatter"],
      correctIndex: 2,
      explanation: "VOR signals travel by line-of-sight propagation and are blocked by terrain and earth's curvature.",
      reference: "VOR Propagation"
    },
    {
      id: "err-202",
      difficulty: 3,
      pointValue: 400,
      timeLimit: 14,
      question: "This type of VOR error is caused by terrain reflections near the ground station.",
      answers: ["Propagation error", "Site error", "Quadrantal error", "Scalloping error"],
      correctIndex: 1,
      explanation: "Site error results from signal reflections off terrain, buildings, or obstructions near the VOR station.",
      reference: "VOR Site Error"
    },
    {
      id: "err-203",
      difficulty: 4,
      pointValue: 600,
      timeLimit: 16,
      question: "VOR quadrantal error is caused by signal reflection off this source.",
      answers: ["Nearby VOR stations", "Aircraft structure", "Ionosphere", "Ground terrain"],
      correctIndex: 1,
      explanation: "Quadrantal error is aircraft-induced error from VOR signal reflection off the aircraft structure, varying with heading.",
      reference: "Quadrantal Error"
    },
    {
      id: "err-204",
      difficulty: 4,
      pointValue: 800,
      timeLimit: 18,
      question: "VOR antennas should be mounted in this location for optimal performance.",
      answers: ["Under the fuselage", "Inside the cockpit", "On top of vertical stabilizer", "On the wing tips"],
      correctIndex: 2,
      explanation: "VOR antennas need clear line-of-sight, typically mounted on top of vertical stabilizer or fuselage to minimize obstructions.",
      reference: "VOR Antenna Placement"
    },
    {
      id: "err-205",
      difficulty: 5,
      pointValue: 1000,
      timeLimit: 20,
      question: "The VOR monitor system automatically does this when parameters exceed tolerances.",
      answers: ["Increases power", "Switches to backup", "Removes identifier or shuts down", "Sends alert to pilots"],
      correctIndex: 2,
      explanation: "VOR monitors automatically remove the identifier or shut down the station if signal integrity fails, preventing unreliable navigation.",
      reference: "VOR Monitoring"
    }
  ],

  // ==================== FINAL JEOPARDY ====================

  FINAL: {
    cat: "VOR Navigation Procedures",
    difficulty: 5,
    timeLimit: 30,
    question: "A pilot tunes a VOR, hears the identifier clearly, but the CDI shows full-scale deflection with the TO/FROM indicator blank. The VOR station is verified operational. What is the most likely cause of this indication?",
    answers: [
      "The aircraft is in the cone of confusion directly over the station",
      "VOR receiver has failed or signal is too weak",
      "Aircraft is beyond the service volume of the VOR",
      "VOR antenna is disconnected or damaged"
    ],
    correctIndex: 1,
    explanation: "If the identifier is heard but the CDI shows OFF flag with no usable navigation, the receiver has likely failed or signal strength is insufficient. If in the cone of confusion, TO/FROM would fluctuate. If the antenna were bad, no identifier would be heard.",
    reference: "VOR System Troubleshooting"
  }
};


/* ========================================================================
   END OF CUSTOMIZABLE QUESTION BANK SECTION
   ======================================================================== */

/* Game State */
const GameState = {
  TILE_SELECTION: 'TILE_SELECTION',
  QUESTION_READING: 'QUESTION_READING',
  BUZZER_ACTIVE: 'BUZZER_ACTIVE',
  ANSWERING: 'ANSWERING',
  SHOWING_RESULT: 'SHOWING_RESULT',
  DAILY_DOUBLE: 'DAILY_DOUBLE',
  ROUND_TRANSITION: 'ROUND_TRANSITION',
  FINAL_JEOPARDY: 'FINAL_JEOPARDY',
  GAME_OVER: 'GAME_OVER'
};

let gameState = GameState.TILE_SELECTION;
let currentRound = 1; // 1 = Jeopardy, 2 = Double Jeopardy
let tiles = {};
let playerScore = 0, aiScore = 0;
let currentTurn = 'player';
let currentQ = null;
let buzzWinner = null;
let dailyDoubleIds = [];
let questionsLeft = 15;
let aiBuzzTimeout = null;

/* AI Settings */
const AI_DIFFICULTY = {
  easy: { reactionMin: 2000, reactionMax: 3500, accuracy: 0.55, name: 'Easy' },
  medium: { reactionMin: 1500, reactionMax: 2500, accuracy: 0.70, name: 'Medium' },
  hard: { reactionMin: 1000, reactionMax: 2000, accuracy: 0.80, name: 'Hard' },
  expert: { reactionMin: 800, reactionMax: 1500, accuracy: 0.88, name: 'Expert' }
};
let currentDifficulty = 'medium';

/* Timer */
let TMAX = 10, t = TMAX, tInt = null, soundOn = true;
/* Track current Daily Double wager so timeouts score correctly */
let currentDDWager = 0;

/* DOM */
const $ = s => document.querySelector(s);
const catRow = $('#catRow'), qLeft = $('#qLeft');
const pScore = $('#pScore'), aiScoreEl = $('#aiScore');
const playerBox = $('#playerBox'), aiBox = $('#aiBox');
const playerTurn = $('#playerTurn'), aiTurn = $('#aiTurn');
const rows = [$('#valRow1'), $('#valRow2'), $('#valRow3'), $('#valRow4'), $('#valRow5')];
const qCard = $('#qCard'), qCat = $('#qCat'), qValue = $('#qValue'), qText = $('#qText');
const choices = $('#choices'), feedback = $('#feedback'), closeQ = $('#closeQ');
const buzzSection = $('#buzzSection'), playerBuzz = $('#playerBuzz'), aiBuzz = $('#aiBuzz');
const qTimer = $('#qTimer'), tFill = $('#tFill'), tLeft = $('#tLeft');
const ddBadge = $('#ddBadge'), ddModal = $('#ddModal');
const confetti = $('#confetti');
const muteBtn = $('#mute'), difficultyBtn = $('#difficultyBtn');
const fjModal = $('#fjModal'), fjCat = $('#fjCat'), fjStart = $('#fjStart');
const fjPScore = $('#fjPScore'), fjAIScore = $('#fjAIScore'), fjPWager = $('#fjPWager'), fjAIWager = $('#fjAIWager');
const finalCard = $('#finalCard'), finalCat = $('#finalCat'), finalText = $('#finalText');
const finalChoices = $('#finalChoices'), finalFeedback = $('#finalFeedback'), closeFinal = $('#closeFinal');
const gameEndModal = $('#gameEndModal'), endGameTitle = $('#endGameTitle');
const endPlayerScore = $('#endPlayerScore'), endAIScore = $('#endAIScore'), endGameMessage = $('#endGameMessage');
const finalRestartBtn = $('#finalRestartBtn');
const roundIndicator = $('#roundIndicator');
const roundTransition = $('#roundTransition'), transitionTitle = $('#transitionTitle'), transitionSubtitle = $('#transitionSubtitle');

/* Audio */
let AC = null;
function ensureAudio() { if (!AC) { AC = new (window.AudioContext || window.webkitAudioContext)(); } if (AC.state === 'suspended') { AC.resume(); } }
function play(freq = 880, ms = 180, type = 'sine', gain = 0.06) {
  if (!soundOn) return;
  ensureAudio();
  const o = AC.createOscillator(), g = AC.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = gain; g.gain.setValueAtTime(gain, AC.currentTime);
  g.gain.exponentialRampToValueAtTime(0.0001, AC.currentTime + ms / 1000);
  o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime + ms / 1000);
}
function chordOK() { play(987, 140, 'sine', 0.08); setTimeout(() => play(1479, 160, 'sine', 0.07), 110); }
function buzzer() {
  if (!soundOn) return; ensureAudio();
  const o = AC.createOscillator(), g = AC.createGain(); o.type = 'square';
  o.frequency.setValueAtTime(120, AC.currentTime); o.frequency.exponentialRampToValueAtTime(70, AC.currentTime + 0.35);
  g.gain.value = 0.08; g.gain.setValueAtTime(0.08, AC.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, AC.currentTime + 0.4);
  o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime + 0.42);
}
function selectBlip() { play(660, 90, 'triangle', 0.06); }
function tick() { play(660, 45, 'sine', 0.03); }
function buzzSound() { play(800, 200, 'square', 0.1); }

function celebrate() {
  const colors = ["#22c55e", "#3b82f6", "#eab308", "#a855f7", "#f43f5e"];
  for (let i = 0; i < 26; i++) {
    const p = document.createElement('i');
    p.style.left = Math.random() * 100 + '%';
    p.style.top = '-10px';
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.transform = 'rotate(' + Math.random() * 360 + 'deg)';
    p.style.animationDelay = (Math.random() * 0.2) + 's';
    confetti.appendChild(p);
    setTimeout(() => p.remove(), 1700);
  }
}

function updateTurnIndicator() {
  playerBox.classList.toggle('active', currentTurn === 'player');
  aiBox.classList.toggle('active', currentTurn === 'ai');
  
  if (gameState === GameState.TILE_SELECTION) {
    playerTurn.textContent = currentTurn === 'player' ? 'ðŸ‘‰ Your Turn to Select' : '';
    aiTurn.textContent = currentTurn === 'ai' ? 'ðŸ‘‰ AI is Selecting...' : '';
  } else {
    playerTurn.textContent = '';
    aiTurn.textContent = '';
  }
}

/* Validate the structure up front so bad data fails fast */
function validateBank() {
  const cats = Object.keys(QUESTION_BANK).filter(k => k !== 'FINAL');
  if (cats.length !== 6) throw new Error(`QUESTION_BANK must have exactly 6 categories (+ FINAL). Found ${cats.length}.`);
  cats.forEach(c => {
    const arr = QUESTION_BANK[c];
    if (!Array.isArray(arr) || arr.length !== 5) {
      throw new Error(`Category "${c}" must contain exactly 5 items (has ${Array.isArray(arr) ? arr.length : 'invalid'}).`);
    }
    arr.forEach((q, i) => {
      if (!Array.isArray(q.answers) || q.answers.length !== 4) {
        throw new Error(`"${c}" item ${i+1} must have exactly 4 answers.`);
      }
      if (q.correctIndex < 0 || q.correctIndex > 3) {
        throw new Error(`"${c}" item ${i+1} has invalid correctIndex (expected 0â€“3).`);
      }
    });
  });
}

function init() {
  validateBank();

  const allCategoryNames = Object.keys(QUESTION_BANK).filter(k => k !== "FINAL");
  // Get first 3 categories for Round 1
  const round1Categories = allCategoryNames.slice(0, 3);
  
  playerScore = 0;
  aiScore = 0;
  currentRound = 1;
  currentTurn = 'player';
  gameState = GameState.TILE_SELECTION;
  currentQ = null;
  buzzWinner = null;
  aiBuzzTimeout = null;
  dailyDoubleIds = [];
  currentDDWager = 0;

  pScore.textContent = '$' + playerScore;
  aiScoreEl.textContent = '$' + aiScore;
  roundIndicator.textContent = 'ROUND 1: JEOPARDY';

  qCard.classList.remove('show');
  finalCard.classList.remove('show');
  gameEndModal.classList.remove('show');
  ddModal.classList.remove('show');
  fjModal.classList.remove('show');
  roundTransition.classList.remove('show');

  loadRound(round1Categories, 1);
}

function loadRound(categories, roundNum) {
  currentRound = roundNum;
  const baseValues = roundNum === 1 ? [100, 200, 300, 400, 500] : [200, 400, 600, 800, 1000];
  
  tiles = {};
  const allRoundQuestions = [];

  categories.forEach(catName => {
    const pool = QUESTION_BANK[catName] || [];

    // Guard: ensure exactly 5 per category
    if (pool.length !== 5) {
      throw new Error(`Category "${catName}" must have exactly 5 questions (has ${pool.length}).`);
    }

    pool.forEach((q, idx) => {
      const id = `${catName}-${baseValues[idx]}`;
      tiles[id] = { 
        ...q,
        id,
        category: catName,      // store the real category
        used: false,
        pointValue: baseValues[idx]
      };
      allRoundQuestions.push(tiles[id]);
    });
  });

  questionsLeft = categories.length * baseValues.length;
  qLeft.textContent = questionsLeft;

  catRow.innerHTML = '';
  categories.forEach(c => {
    const el = document.createElement('div');
    el.className = 'cat';
    el.textContent = c;
    catRow.appendChild(el);
  });

  rows.forEach((r, i) => {
    r.innerHTML = '';
    const v = baseValues[i];
    categories.forEach(catName => {
      const id = `${catName}-${v}`;
      const t = document.createElement('button');
      t.className = 'tile';
      t.textContent = `$${v}`;
      t.dataset.id = id;

      if (tiles[id]) {
        t.addEventListener('click', () => {
          if (gameState === GameState.TILE_SELECTION && currentTurn === 'player' && !tiles[id].used) {
            openTile(id, t);
          }
        });
      }
      r.appendChild(t);
    });
  });

  // Select Daily Doubles for this round
  const candidates = allRoundQuestions.filter(q => q.difficulty >= 3 && q.pointValue >= (roundNum === 1 ? 300 : 600));
  const numDailyDoubles = roundNum === 1 ? 1 : 2;
  dailyDoubleIds = [];
  
  for (let i = 0; i < numDailyDoubles && candidates.length > 0; i++) {
    const idx = Math.floor(Math.random() * candidates.length);
    dailyDoubleIds.push(candidates[idx].id);
    candidates.splice(idx, 1);
  }

  updateTurnIndicator();
}

function openTile(id, btn) {
  const data = tiles[id];
  if (!data || data.used) return;
  
  data.used = true;
  btn.classList.add('used');
  btn.innerHTML = 'â€”';
  selectBlip();
  
  const isDailyDouble = dailyDoubleIds.includes(id);
  
  if (isDailyDouble) {
    showDailyDouble(data);
  } else {
    showQuestion(data);
  }
}

function aiSelectTile() {
  const availableTiles = Object.values(tiles).filter(t => !t.used);
  if (availableTiles.length === 0) {
    if (currentRound === 1) {
      startRound2();
    } else {
      openFinalJeopardy();
    }
    return;
  }

  gameState = GameState.TILE_SELECTION;
  updateTurnIndicator();

  availableTiles.forEach(t => {
    const btn = document.querySelector(`[data-id="${t.id}"]`);
    if (btn) btn.classList.add('ai-thinking');
  });

  setTimeout(() => {
    let selected;
    if (aiScore < playerScore - 300) {
      const highValue = availableTiles.filter(t => t.pointValue >= (currentRound === 1 ? 400 : 800));
      selected = highValue.length > 0 ? highValue[Math.floor(Math.random() * highValue.length)] : availableTiles[0];
    } else {
      selected = availableTiles[Math.floor(Math.random() * availableTiles.length)];
    }

    availableTiles.forEach(t => {
      const btn = document.querySelector(`[data-id="${t.id}"]`);
      if (btn) btn.classList.remove('ai-thinking');
    });

    const btn = document.querySelector(`[data-id="${selected.id}"]`);
    openTile(selected.id, btn);
  }, 1000 + Math.random() * 1000);
}

function startRound2() {
  gameState = GameState.ROUND_TRANSITION;
  
  // Determine who starts Round 2 (lower score)
  if (playerScore < aiScore) {
    currentTurn = 'player';
  } else if (aiScore < playerScore) {
    currentTurn = 'ai';
  } else {
    currentTurn = 'player';
  }
  
  transitionTitle.textContent = 'DOUBLE JEOPARDY';
  transitionSubtitle.textContent = 'All values are doubled! ' + (currentTurn === 'player' ? 'You start this round!' : 'AI starts this round!');
  roundTransition.classList.add('show');
  
  setTimeout(() => {
    roundTransition.classList.remove('show');
    roundIndicator.textContent = 'ROUND 2: DOUBLE JEOPARDY';
    
    // Load Round 2 categories (second set of 3)
    const allCategoryNames = Object.keys(QUESTION_BANK).filter(k => k !== "FINAL");
    const round2Categories = allCategoryNames.slice(3, 6);
    
    loadRound(round2Categories, 2);
    
    gameState = GameState.TILE_SELECTION;
    updateTurnIndicator();
    
    if (currentTurn === 'ai') {
      setTimeout(() => aiSelectTile(), 1000);
    }
  }, 3000);
}

function showDailyDouble(data) {
  currentQ = data;
  const isDDOwner = currentTurn;
  
  ddModal.classList.add('show');
  $('#ddWho').innerHTML = isDDOwner === 'player' 
    ? '<div style="color:var(--player);font-weight:700">You found the Daily Double!</div>'
    : '<div style="color:var(--ai);font-weight:700">AI found the Daily Double!</div>';
  
  const score = isDDOwner === 'player' ? playerScore : aiScore;
  $('#ddScoreDisplay').innerHTML = `Current Score: <b class="kpi">$${score}</b>`;
  
  if (isDDOwner === 'player') {
    const maxWager = Math.max(currentRound === 1 ? 1000 : 2000, score);
    $('#ddWagerSection').innerHTML = `
      <div>Wager an amount (min $100, max $${maxWager}):</div>
      <div class="input"><span>$</span><input id="ddWagerInput" type="number" min="100" max="${maxWager}" value="${Math.min(maxWager, currentRound === 1 ? 500 : 1000)}" step="50"></div>
    `;
    $('#ddButtons').innerHTML = '<button id="ddStartBtn" class="btn">Answer Question</button>';
    $('#ddStartBtn').addEventListener('click', () => {
      const wager = Math.max(100, Math.min(maxWager, Number($('#ddWagerInput').value) || 100));
      ddModal.classList.remove('show');
      showQuestion(data, true, wager);
    });
  } else {
    const maxWager = Math.max(currentRound === 1 ? 1000 : 2000, score);
    const aiWager = Math.floor(maxWager * (0.3 + Math.random() * 0.5));
    $('#ddWagerSection').innerHTML = `<div>AI is considering their wager...</div>`;
    $('#ddButtons').innerHTML = '';
    
    setTimeout(() => {
      $('#ddWagerSection').innerHTML = `<div>AI wagers: <b class="kpi">$${aiWager}</b></div>`;
      setTimeout(() => {
        ddModal.classList.remove('show');
        showQuestion(data, true, aiWager);
      }, 1500);
    }, 2000);
  }
}

function showQuestion(data, isDailyDouble = false, ddWager = 0) {
  currentQ = data;
  gameState = GameState.QUESTION_READING;
  buzzWinner = null;
  currentDDWager = isDailyDouble ? ddWager : 0; // remember DD wager
  
  qCard.classList.add('show');
  
  // Use stored category instead of parsing the id
  const catName = data.category;
  qCat.textContent = catName;
  qValue.textContent = '$' + data.pointValue;
  qText.textContent = data.question;
  choices.innerHTML = '';
  feedback.innerHTML = '';
  closeQ.classList.add('hidden');
  buzzSection.classList.add('hidden');
  ddBadge.style.display = isDailyDouble ? 'inline-block' : 'none';
  
  if (isDailyDouble) {
    qTimer.style.visibility = 'visible';
    startAnswerTimer(data.timeLimit || 15);
    
    setTimeout(() => {
      gameState = GameState.ANSWERING;
      showAnswerChoices(isDailyDouble, ddWager);
    }, 2000);
  } else {
    qTimer.style.visibility = 'hidden';
    
    setTimeout(() => {
      gameState = GameState.BUZZER_ACTIVE;
      showBuzzerSection();
    }, 3000);
  }
}

function showBuzzerSection() {
  buzzSection.classList.remove('hidden');
  playerBuzz.disabled = false;
  playerBuzz.classList.remove('winner');
  aiBuzz.classList.remove('winner');
  buzzSound();
  
  const aiSettings = AI_DIFFICULTY[currentDifficulty];
  const aiReactionTime = aiSettings.reactionMin + Math.random() * (aiSettings.reactionMax - aiSettings.reactionMin);
  
  let playerBuzzed = false;
  
  playerBuzz.onclick = () => {
    if (gameState !== GameState.BUZZER_ACTIVE || playerBuzzed) return;
    playerBuzzed = true;
    buzzWinner = 'player';
    if (aiBuzzTimeout) clearTimeout(aiBuzzTimeout);
    handleBuzzWin();
  };
  
  aiBuzzTimeout = setTimeout(() => {
    if (gameState === GameState.BUZZER_ACTIVE && !playerBuzzed) {
      buzzWinner = 'ai';
      handleBuzzWin();
    }
  }, aiReactionTime);
}

function handleBuzzWin() {
  gameState = GameState.ANSWERING;
  playerBuzz.disabled = true;
  buzzSound();
  
  if (buzzWinner === 'player') {
    playerBuzz.classList.add('winner');
  } else {
    aiBuzz.classList.add('winner');
  }
  
  setTimeout(() => {
    buzzSection.classList.add('hidden');
    qTimer.style.visibility = 'visible';
    startAnswerTimer(currentQ.timeLimit || 10);
    showAnswerChoices(false, 0);
  }, 1000);
}

function showAnswerChoices(isDailyDouble, ddWager) {
  choices.innerHTML = '';
  
  currentQ.answers.forEach((t, idx) => {
    const b = document.createElement('button');
    b.className = 'choice';
    b.innerHTML = '<strong>' + String.fromCharCode(65 + idx) + '.</strong> ' + t;
    b.dataset.idx = idx;
    
    if (isDailyDouble) {
      if (currentTurn === 'player') {
        b.addEventListener('click', () => handleAnswer(idx, true, ddWager));
      } else {
        b.disabled = true;
      }
    } else {
      if (buzzWinner === 'player') {
        b.addEventListener('click', () => handleAnswer(idx, false, 0));
      } else {
        b.disabled = true;
      }
    }
    
    choices.appendChild(b);
  });
  
  if ((isDailyDouble && currentTurn === 'ai') || (!isDailyDouble && buzzWinner === 'ai')) {
    const aiSettings = AI_DIFFICULTY[currentDifficulty];
    const thinkTime = 1000 + Math.random() * 2000;
    
    setTimeout(() => {
      const correctAnswer = currentQ.correctIndex;
      let aiAnswer;
      
      if (Math.random() < aiSettings.accuracy) {
        aiAnswer = correctAnswer;
      } else {
        const wrongAnswers = [0, 1, 2, 3].filter(i => i !== correctAnswer);
        aiAnswer = wrongAnswers[Math.floor(Math.random() * wrongAnswers.length)];
      }
      
      handleAnswer(aiAnswer, isDailyDouble, ddWager);
    }, thinkTime);
  }
}

function handleAnswer(answerIdx, isDailyDouble, ddWager) {
  stopTimer();
  gameState = GameState.SHOWING_RESULT;
  
  [...choices.children].forEach(b => b.disabled = true);
  
  const correct = currentQ.correctIndex;
  const isCorrect = (answerIdx === correct);
  const answerer = isDailyDouble ? currentTurn : buzzWinner;
  const value = isDailyDouble ? ddWager : currentQ.pointValue;
  
  if (isCorrect) {
    choices.children[correct].classList.add('correct');
    if (answerer === 'player') {
      playerScore += value;
      pScore.textContent = '$' + playerScore;
    } else {
      aiScore += value;
      aiScoreEl.textContent = '$' + aiScore;
    }
    chordOK();
    celebrate();
    currentTurn = answerer;
  } else {
    if (answerIdx >= 0 && choices.children[answerIdx]) choices.children[answerIdx].classList.add('wrong');
    choices.children[correct].classList.add('correct');
    if (answerer === 'player') {
      playerScore -= value;
      pScore.textContent = '$' + playerScore;
    } else {
      aiScore -= value;
      aiScoreEl.textContent = '$' + aiScore;
    }
    buzzer();
    
    if (!isDailyDouble) {
      currentTurn = answerer === 'player' ? 'ai' : 'player';
    }
  }
  
  showExplanation(currentQ, isCorrect, answerer);
  closeQ.classList.remove('hidden');
}

function showExplanation(question, wasCorrect, answerer) {
  const answererName = answerer === 'player' ? 'You' : 'AI';
  const resultText = wasCorrect ? `âœ“ ${answererName} answered correctly!` : `âœ— ${answererName} answered incorrectly`;
  
  const explanationDiv = document.createElement('div');
  explanationDiv.className = 'explanation';
  explanationDiv.innerHTML = `
    <h4>${resultText}</h4>
    <p><strong>Explanation:</strong> ${question.explanation}</p>
    ${question.reference ? `<p><small>ðŸ“š Reference: ${question.reference}</small></p>` : ''}
  `;
  feedback.appendChild(explanationDiv);
}

closeQ.addEventListener('click', () => {
  qCard.classList.remove('show');
  closeQ.classList.add('hidden');
  checkEndOrNext();
});

function checkEndOrNext() {
  questionsLeft = Object.values(tiles).filter(t => !t.used).length;
  qLeft.textContent = questionsLeft;
  
  if (questionsLeft === 0) {
    if (currentRound === 1) {
      startRound2();
    } else {
      openFinalJeopardy();
    }
  } else {
    gameState = GameState.TILE_SELECTION;
    updateTurnIndicator();
    
    if (currentTurn === 'ai') {
      aiSelectTile();
    }
  }
}

function openFinalJeopardy() {
  gameState = GameState.FINAL_JEOPARDY;
  fjCat.textContent = QUESTION_BANK.FINAL.cat;
  fjPScore.textContent = '$' + playerScore;
  fjAIScore.textContent = '$' + aiScore;
  fjPWager.max = Math.max(0, playerScore);
  fjPWager.value = Math.max(0, Math.min(playerScore, Math.floor(playerScore / 2)));
  fjAIWager.textContent = '$???';
  fjModal.classList.add('show');
}

fjStart.addEventListener('click', () => {
  const playerWager = Math.max(0, Math.min(playerScore, Number(fjPWager.value) || 0));
  
  let aiWager;
  if (aiScore > playerScore) {
    aiWager = Math.max(0, Math.min(aiScore, playerScore * 2 - aiScore + 100));
  } else {
    aiWager = Math.max(0, aiScore);
  }
  aiWager = Math.max(0, Math.min(aiScore, aiWager));
  
  fjModal.classList.remove('show');
  renderFinalQuestion(playerWager, aiWager);
});

function renderFinalQuestion(playerWager, aiWager) {
  finalCard.classList.add('show');
  finalCat.textContent = QUESTION_BANK.FINAL.cat;
  finalText.textContent = QUESTION_BANK.FINAL.question;
  finalChoices.innerHTML = '';
  finalFeedback.innerHTML = '';
  closeFinal.classList.add('hidden');
  
  QUESTION_BANK.FINAL.answers.forEach((t, idx) => {
    const b = document.createElement('button');
    b.className = 'choice';
    b.innerHTML = `<strong>${String.fromCharCode(65 + idx)}.</strong> ${t}`;
    b.addEventListener('click', () => {
      handleFinalAnswer(idx, playerWager, aiWager);
    });
    finalChoices.appendChild(b);
  });
}

function handleFinalAnswer(playerAnswerIdx, playerWager, aiWager) {
  [...finalChoices.children].forEach(b => b.disabled = true);
  
  const correct = QUESTION_BANK.FINAL.correctIndex;
  const playerCorrect = (playerAnswerIdx === correct);
  
  const aiSettings = AI_DIFFICULTY[currentDifficulty];
  const aiCorrect = Math.random() < (aiSettings.accuracy * 0.85);
  
  finalChoices.children[playerAnswerIdx].classList.add(playerCorrect ? 'correct' : 'wrong');
  if (!playerCorrect) {
    finalChoices.children[correct].classList.add('correct');
  }
  
  if (playerCorrect) {
    playerScore += playerWager;
  } else {
    playerScore -= playerWager;
  }
  
  if (aiCorrect) {
    aiScore += aiWager;
  } else {
    aiScore -= aiWager;
  }
  
  pScore.textContent = '$' + playerScore;
  aiScoreEl.textContent = '$' + aiScore;
  
  const expDiv = document.createElement('div');
  expDiv.className = 'explanation';
  expDiv.innerHTML = `
    <h4>Final Jeopardy Results</h4>
    <p><strong>Your answer:</strong> ${playerCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect'} (Wagered $${playerWager})</p>
    <p><strong>AI answer:</strong> ${aiCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect'} (Wagered $${aiWager})</p>
    <p><strong>Explanation:</strong> ${QUESTION_BANK.FINAL.explanation}</p>
    ${QUESTION_BANK.FINAL.reference ? `<p><small>ðŸ“š Reference: ${QUESTION_BANK.FINAL.reference}</small></p>` : ''}
  `;
  finalFeedback.appendChild(expDiv);
  
  if (playerCorrect) chordOK();
  else buzzer();
  
  closeFinal.classList.remove('hidden');
}

closeFinal.addEventListener('click', () => {
  finalCard.classList.remove('show');
  endGame();
});

function endGame() {
  gameState = GameState.GAME_OVER;
  gameEndModal.classList.add('show');

  endPlayerScore.textContent = '$' + playerScore;
  endAIScore.textContent = '$' + aiScore;

  if (playerScore > aiScore) {
    endGameTitle.textContent = 'ðŸ† YOU WIN!';
    endGameMessage.textContent = `Congratulations! You defeated the AI ${AI_DIFFICULTY[currentDifficulty].name} opponent by $${playerScore - aiScore}. Excellent knowledge!`;
    celebrate();
  } else if (aiScore > playerScore) {
    endGameTitle.textContent = 'ðŸ¤– AI WINS!';
    endGameMessage.textContent = `The AI ${AI_DIFFICULTY[currentDifficulty].name} opponent won by $${aiScore - playerScore}. Review the explanations and try again!`;
  } else {
    endGameTitle.textContent = 'ðŸ¤ TIE GAME!';
    endGameMessage.textContent = `You and the AI ${AI_DIFFICULTY[currentDifficulty].name} opponent tied! That's impressive.`;
  }

  // Auto-report score to parent page for gamification
  reportJeopardyScore(playerScore, aiScore);
}

function startAnswerTimer(timeLimit) {
  stopTimer();
  TMAX = timeLimit;
  t = TMAX;
  tLeft.textContent = t;
  tFill.style.transition = 'none';
  tFill.style.width = '100%';
  void tFill.offsetWidth;
  tFill.style.transition = 'width 1s linear';
  
  tInt = setInterval(() => {
    t--;
    tLeft.textContent = t;
    const percent = (t / TMAX) * 100;
    tFill.style.width = percent + '%';
    if (t <= 5 && t > 0) tick();
    if (t <= 0) {
      stopTimer();
      const isDD = ddBadge.style.display !== 'none';
      handleAnswer(-1, isDD, isDD ? currentDDWager : 0); // use stored DD wager on timeout
    }
  }, 1000);
}

function stopTimer() {
  clearInterval(tInt);
  tInt = null;
}

muteBtn.addEventListener('click', () => {
  soundOn = !soundOn;
  muteBtn.textContent = soundOn ? 'ðŸ”ˆ Sound' : 'ðŸ”‡ Muted';
});

difficultyBtn.addEventListener('click', () => {
  const difficulties = ['easy', 'medium', 'hard', 'expert'];
  const currentIdx = difficulties.indexOf(currentDifficulty);
  currentDifficulty = difficulties[(currentIdx + 1) % difficulties.length];
  difficultyBtn.textContent = `AI: ${AI_DIFFICULTY[currentDifficulty].name}`;
});

finalRestartBtn.addEventListener('click', init);
document.addEventListener('click', () => { ensureAudio(); }, { once: true });

init();

// ============================================================================
// GAMIFICATION INTEGRATION - Auto-report score when game ends
// ============================================================================
function reportJeopardyScore(playerScore, aiScore) {
  const totalScore = playerScore + aiScore;
  const percentage = totalScore > 0 ? Math.round((playerScore / totalScore) * 100) : 0;

  try {
    if (window.parent && window.parent.completeModule) {
      window.parent.completeModule('jeopardy', percentage);
    }
  } catch(e) {
    // Running in standalone mode - no gamification
  }
}

window.reportJeopardyScore = reportJeopardyScore;
</script>

</body>
</html>
